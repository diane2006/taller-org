<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buses del Sistema y Tarjetas de Expansi√≥n</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <div class="header-content">
      <div class="">Arquitectura Computacional</div>
      <nav>
        <ul>
          <li><a href="#" data-page="intro" class="nav-link active">Introducci√≥n</a></li>
          <li><a href="#" data-page="objetivo" class="nav-link">Objetivo</a></li>
          <li><a href="#" data-page="desarrollo" class="nav-link">Desarrollo</a></li>
          <li><a href="#" data-page="caso" class="nav-link">Caso de Estudio</a></li>
          <li><a href="#" data-page="conclusion" class="nav-link">Conclusiones</a></li>
          <li><a href="#" data-page="referencias" class="nav-link">Referencias</a></li>
        </ul>
      </nav>
      <button class="theme-toggle" id="themeToggle">Modo Oscuro</button>
    </div>
  </header>

  <main class="container">
    <!-- P√°gina 1: Introducci√≥n -->
    <section id="intro" class="page-section active">
      <div class="hero">
        <h1>Buses del Sistema y Tarjetas de Expansi√≥n</h1>
        <p>Comprendiendo la arquitectura del hardware para desarrollar mejor software</p>
      </div>

      <div class="card">
        <h2>Introducci√≥n</h2>
        <p>En el mundo del desarrollo de software, comprender la arquitectura del hardware no es solo una ventaja competitiva, sino una necesidad fundamental. Los <span class="highlight">buses del sistema</span> y las <span class="highlight">tarjetas de expansi√≥n</span> forman el n√∫cleo de la comunicaci√≥n entre componentes dentro de una computadora, determinando la velocidad, eficiencia y capacidad de un sistema.</p>
        
        <div class="grid-2">
          <div class="feature-box">
            <h4> ¬øPor qu√© es importante?</h4>
            <p>Un desarrollador que comprende c√≥mo funcionan los buses del sistema puede optimizar el rendimiento de sus aplicaciones, identificar cuellos de botella y dise√±ar soluciones que aprovechen al m√°ximo las capacidades del hardware.</p>
          </div>
          
          <div class="feature-box">
            <h4> Relevancia para desarrolladores</h4>
            <p>El conocimiento de estos componentes permite tomar decisiones informadas sobre compatibilidad, rendimiento y escalabilidad, especialmente en aplicaciones que requieren alta velocidad de procesamiento o interacci√≥n directa con hardware.</p>
          </div>
        </div>

        <div class="info-box blue">
          <h3>Visi√≥n General</h3>
          <p>Los buses del sistema son las "autopistas de informaci√≥n" que conectan todos los componentes de una computadora. Las tarjetas de expansi√≥n permiten a√±adir nuevas capacidades al sistema. Juntos, definen las posibilidades y limitaciones de cualquier plataforma computacional.</p>
          <ul>
            <li><strong>Buses del Sistema:</strong> Transferencia de datos, direcciones y se√±ales de control</li>
            <li><strong>Tarjetas de Expansi√≥n:</strong> Gr√°ficas, red, sonido, captura de datos, etc.</li>
            <li><strong>Impacto en Software:</strong> Rendimiento, compatibilidad y optimizaci√≥n</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- P√°gina 2: Objetivo -->
    <section id="objetivo" class="page-section">
      <div class="hero">
        <h1> Objetivo del Trabajo</h1>
        <p>Conectando hardware y software en el desarrollo moderno</p>
      </div>

      <div class="card">
        <h2> Prop√≥sito</h2>
        <p>El objetivo principal de este trabajo es <span class="highlight">establecer una comprensi√≥n profunda de la relaci√≥n entre hardware y software</span>, espec√≠ficamente enfoc√°ndose en c√≥mo los buses del sistema y las tarjetas de expansi√≥n impactan el desarrollo de aplicaciones.</p>

        <div class="grid-3">
          <div class="info-box blue">
            <h4> Objetivo Acad√©mico</h4>
            <p>Analizar y documentar los fundamentos t√©cnicos de los buses del sistema y tarjetas de expansi√≥n desde una perspectiva de desarrollo de software.</p>
          </div>

          <div class="info-box purple">
            <h4> Objetivo Pr√°ctico</h4>
            <p>Aplicar el conocimiento te√≥rico a casos reales donde la integraci√≥n hardware-software es cr√≠tica para el √©xito del proyecto.</p>
          </div>

          <div class="info-box cyan">
            <h4> Objetivo Profesional</h4>
            <p>Desarrollar competencias que permitan tomar decisiones t√©cnicas informadas en proyectos de software que requieran interacci√≥n con hardware.</p>
          </div>
        </div>

        <div class="card">
          <h3> Conexi√≥n Hardware-Software</h3>
          <p>En el entorno de desarrollo moderno, la l√≠nea entre hardware y software se vuelve cada vez m√°s difusa. Los desarrolladores deben:</p>
          
          <div class="grid-2">
            <div class="feature-box">
              <h4>Comprender las limitaciones f√≠sicas</h4>
              <ul>
                <li>Ancho de banda de buses</li>
                <li>Latencias de comunicaci√≥n</li>
                <li>Compatibilidad de interfaces</li>
              </ul>
            </div>

            <div class="feature-box">
              <h4>Optimizar seg√∫n el hardware</h4>
              <ul>
                <li>Gesti√≥n eficiente de memoria</li>
                <li>Uso de DMA y buffers</li>
                <li>Threading y paralelizaci√≥n</li>
              </ul>
            </div>
          </div>

          <div class="info-box green">
            <p><strong>Meta Final:</strong> Capacitar a los desarrolladores para crear software que no solo funcione, sino que aproveche al m√°ximo las capacidades del hardware disponible, resultando en aplicaciones m√°s r√°pidas, eficientes y confiables.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- P√°gina 3: Desarrollo -->
    <section id="desarrollo" class="page-section">
      <div class="hero">
        <h1>Desarrollo de Contenidos</h1>
        <p>An√°lisis t√©cnico detallado</p>
      </div>

      <div class="card">
        <h2>Buses del Sistema</h2>
        <p>Los buses del sistema son conjuntos de l√≠neas de comunicaci√≥n que permiten la transferencia de informaci√≥n entre los diferentes componentes de una computadora.</p>

        <h3>Tipos de Buses</h3>
        
        <table>
          <thead>
            <tr>
              <th>Tipo de Bus</th>
              <th>Funci√≥n</th>
              <th>Caracter√≠sticas</th>
              <th>Impacto en Software</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Bus de Datos</strong></td>
              <td>Transporta datos entre componentes</td>
              <td>Ancho: 32, 64, 128 bits<br>Bidireccional</td>
              <td>Define tama√±o m√°ximo de transferencia por ciclo</td>
            </tr>
            <tr>
              <td><strong>Bus de Direcciones</strong></td>
              <td>Especifica ubicaciones de memoria</td>
              <td>Unidireccional<br>Define espacio direccionable</td>
              <td>Limita cantidad de RAM utilizable</td>
            </tr>
            <tr>
              <td><strong>Bus de Control</strong></td>
              <td>Se√±ales de sincronizaci√≥n</td>
              <td>Controla lectura/escritura<br>Temporizaci√≥n</td>
              <td>Afecta latencia y sincronizaci√≥n</td>
            </tr>
          </tbody>
        </table>

        <div class="info-box purple">
          <h4> Ejemplo Pr√°ctico</h4>
          <p>Un bus de datos de 64 bits puede transferir 8 bytes por ciclo. Si tu aplicaci√≥n procesa im√°genes de alta resoluci√≥n, comprender esto te permite optimizar el tama√±o de los bloques de datos que procesas en cada iteraci√≥n.</p>
        </div>

        <h3>Arquitecturas de Bus Modernas</h3>
        
        <div class="grid-2">
          <div class="feature-box">
            <h4>PCI Express (PCIe)</h4>
            <ul>
              <li><strong>Tipo:</strong> Serial, punto a punto</li>
              <li><strong>Velocidad:</strong> Hasta 32 GT/s (Gen 5)</li>
              <li><strong>Lanes:</strong> x1, x4, x8, x16</li>
              <li><strong>Uso:</strong> GPUs, SSDs NVMe, tarjetas de red</li>
            </ul>
          </div>

          <div class="feature-box">
            <h4>USB (Universal Serial Bus)</h4>
            <ul>
              <li><strong>Tipo:</strong> Serial, hot-pluggable</li>
              <li><strong>Velocidad:</strong> Hasta 40 Gbps (USB4)</li>
              <li><strong>Caracter√≠sticas:</strong> Plug and play</li>
              <li><strong>Uso:</strong> Perif√©ricos, almacenamiento</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="card">
        <h2> Tarjetas de Expansi√≥n</h2>
        <p>Las tarjetas de expansi√≥n permiten a√±adir funcionalidades espec√≠ficas a un sistema computacional.</p>

        <h3>Tipos Principales</h3>
        
        <div class="grid-3">
          <div class="info-box blue">
            <h4> Tarjetas Gr√°ficas (GPU)</h4>
            <ul>
              <li>Procesamiento paralelo</li>
              <li>Renderizado 3D</li>
              <li>C√°lculos cient√≠ficos (CUDA, OpenCL)</li>
              <li>Machine Learning</li>
            </ul>
          </div>

          <div class="info-box cyan">
            <h4>Tarjetas de Red</h4>
            <ul>
              <li>Ethernet 1/10/25/100 Gbps</li>
              <li>Wi-Fi 6/6E/7</li>
              <li>Offloading de TCP/IP</li>
              <li>Virtualizaci√≥n de red</li>
            </ul>
          </div>

          <div class="info-box purple">
            <h4> Tarjetas de Captura</h4>
            <ul>
              <li>Adquisici√≥n de datos en tiempo real</li>
              <li>Conversi√≥n A/D y D/A</li>
              <li>Sensores industriales</li>
              <li>Instrumentaci√≥n cient√≠fica</li>
            </ul>
          </div>
        </div>

        <h3>Relaci√≥n con Memoria y Perif√©ricos</h3>
        
        <div class="info-box yellow">
          <h4> DMA (Direct Memory Access)</h4>
          <p>Las tarjetas modernas usan DMA para transferir datos directamente a la memoria sin intervenci√≥n del CPU, liberando recursos de procesamiento. Esto es cr√≠tico para:</p>
          <ul>
            <li>Captura de video en alta resoluci√≥n</li>
            <li>Transferencias de red de alta velocidad</li>
            <li>Lectura/escritura de SSDs NVMe</li>
            <li>Procesamiento de audio en tiempo real</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h2> Impacto en el Desarrollo de Software</h2>
        
        <h3>Rendimiento y Optimizaci√≥n</h3>
        
        <div class="grid-2">
          <div class="feature-box">
            <h4> Buenas Pr√°cticas</h4>
            <ul>
              <li>Alinear estructuras de datos al tama√±o del bus</li>
              <li>Usar buffers apropiados para DMA</li>
              <li>Implementar transferencias as√≠ncronas</li>
              <li>Aprovechar memoria compartida en GPUs</li>
            </ul>
          </div>

          <div class="feature-box">
            <h4> Errores Comunes</h4>
            <ul>
              <li>Transferencias peque√±as y frecuentes</li>
              <li>Ignorar l√≠mites de ancho de banda</li>
              <li>No considerar latencias del bus</li>
              <li>Polling continuo en lugar de interrupciones</li>
            </ul>
          </div>
        </div>

        

        <div class="case-study">
          <div class="case-study-header">
            <span class="case-study-icon"></span>
            <div>
              <h4>Caso 3: Limitaci√≥n de Direccionamiento de Memoria</h4>
              <p><strong>Problema:</strong> Aplicaci√≥n de base de datos en servidor</p>
            </div>
          </div>
          <p><strong>Situaci√≥n:</strong> Un servidor con 128GB de RAM solo reconoc√≠a 64GB en la aplicaci√≥n.</p>
          <p><strong>Causa:</strong> La aplicaci√≥n era de 32 bits, limitada por el bus de direcciones a 4GB (o 64GB con PAE en algunos sistemas). El sistema operativo era de 64 bits pero la aplicaci√≥n no.</p>
          <p><strong>Soluci√≥n:</strong> Recompilar la aplicaci√≥n para arquitectura de 64 bits.</p>
          <p><strong>Lecci√≥n:</strong> El ancho del bus de direcciones define los l√≠mites f√≠sicos de memoria accesible. Las decisiones de arquitectura de software deben considerar estos l√≠mites.</p>
        </div>
      </div>

      <div class="card">
        <h2> Cuadro Comparativo: Buses Modernos</h2>
        
        <table>
          <thead>
            <tr>
              <th>Bus</th>
              <th>Ancho de Banda</th>
              <th>Latencia</th>
              <th>Casos de Uso</th>
              <th>Consideraciones SW</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>PCIe 4.0 x16</strong></td>
              <td>~32 GB/s</td>
              <td>Muy baja (~100ns)</td>
              <td>GPUs de alto rendimiento</td>
              <td>Requiere drivers optimizados, DMA</td>
            </tr>
            <tr>
              <td><strong>USB 3.2 Gen 2</strong></td>
              <td>~2.5 GB/s</td>
              <td>Media (~1-10¬µs)</td>
              <td>Almacenamiento externo</td>
              <td>Transferencias as√≠ncronas, buffering</td>
            </tr>
            <tr>
              <td><strong>SATA III</strong></td>
              <td>~600 MB/s</td>
              <td>Baja</td>
              <td>SSDs, HDDs</td>
              <td>I/O as√≠ncrono, cach√© del SO</td>
            </tr>
            <tr>
              <td><strong>NVMe (PCIe)</strong></td>
              <td>~7 GB/s (Gen 4)</td>
              <td>Muy baja</td>
              <td>SSDs de alto rendimiento</td>
              <td>Queue depth alto, I/O ring buffers</td>
            </tr>
            <tr>
              <td><strong>Thunderbolt 4</strong></td>
              <td>~5 GB/s</td>
              <td>Baja</td>
              <td>Displays, almacenamiento, docking</td>
              <td>M√∫ltiples protocolos, daisy-chaining</td>
            </tr>
          </tbody>
        </table>

        <div class="diagram">
          <h3>Diagrama: Flujo de Datos en el Sistema</h3>
          <pre>
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ     CPU     ‚îÇ
    ‚îÇ   (N√∫cleos) ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ Bus del Sistema
           ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                                 ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  RAM   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ Bus ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Chipset   ‚îÇ
‚îÇ (DDR4) ‚îÇ    de Memoria      ‚îÇ  (Puente)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                     ‚îÇ
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                        ‚îÇ            ‚îÇ            ‚îÇ
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇPCIe Slots ‚îÇ ‚îÇ  USB   ‚îÇ ‚îÇ  SATA    ‚îÇ
                  ‚îÇ  (GPUs,   ‚îÇ ‚îÇ  Ports ‚îÇ ‚îÇ  Ports   ‚îÇ
                  ‚îÇ  NICs)    ‚îÇ ‚îÇ        ‚îÇ ‚îÇ          ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          </pre>
        </div>
      </div>
    </section>

    <!-- P√°gina 4: Caso de Estudio -->
    <section id="caso" class="page-section">
      <div class="hero">
        <h1>Caso de Estudio</h1>
        <p>Integraci√≥n de Hardware Especializado en Software Nuevo</p>
      </div>

      <div class="card">
        <h2> Planteamiento del Caso</h2>
        <div class="info-box yellow">
          <h3>Escenario</h3>
          <p>Un desarrollador debe programar una aplicaci√≥n que se comunique con una <span class="highlight">tarjeta de expansi√≥n de captura de datos</span> para monitoreo industrial en tiempo real. La tarjeta captura se√±ales anal√≥gicas de m√∫ltiples sensores (temperatura, presi√≥n, vibraci√≥n) a una frecuencia de muestreo de 100 kHz por canal.</p>
        </div>

        <h3> Requerimientos del Sistema</h3>
        
        <div class="grid-2">
          <div class="info-box blue">
            <h4>Hardware</h4>
            <ul>
              <li><strong>Tarjeta:</strong> PCIe x4 con 16 canales anal√≥gicos</li>
              <li><strong>Resoluci√≥n:</strong> 16 bits por muestra</li>
              <li><strong>Buffer integrado:</strong> 8 MB FIFO</li>
              <li><strong>DMA:</strong> Soporte para transferencias directas</li>
              <li><strong>Interrupciones:</strong> MSI-X para notificaciones</li>
              <li><strong>Reloj:</strong> Sincronizaci√≥n por hardware</li>
            </ul>
          </div>

          <div class="info-box purple">
            <h4>Software</h4>
            <ul>
              <li><strong>SO:</strong> Windows/Linux compatible</li>
              <li><strong>Driver:</strong> Kernel-mode driver proporcionado</li>
              <li><strong>SDK:</strong> API en C/C++ y Python</li>
              <li><strong>Latencia:</strong> < 10 ms de extremo a extremo</li>
              <li><strong>Almacenamiento:</strong> Streaming a disco en tiempo real</li>
              <li><strong>UI:</strong> Visualizaci√≥n en tiempo real</li>
            </ul>
          </div>
        </div>

        <h3> An√°lisis de Requerimientos</h3>

        <h4>1. C√°lculo de Ancho de Banda</h4>
        <div class="info-box cyan">
          <pre>Tasa de datos = 16 canales √ó 100,000 muestras/s √ó 2 bytes/muestra
              = 3,200,000 bytes/s
              = ~3.2 MB/s por canal
              = ~51.2 MB/s total (16 canales)

Con overhead del protocolo (~20%): ~62 MB/s requeridos</pre>
          
          <p><strong>An√°lisis:</strong> PCIe x4 Gen 3 proporciona ~4 GB/s, suficiente para este caso con margen amplio. El bus no ser√° el cuello de botella.</p>
        </div>

        <h4>2. Arquitectura de Software</h4>
        
        <div class="card">
          <h3>Componentes del Sistema</h3>
          
          <div class="grid-3">
            <div class="feature-box">
              <h4> Capa de Driver</h4>
              <ul>
                <li>Manejo de interrupciones MSI-X</li>
                <li>Configuraci√≥n de DMA</li>
                <li>Gesti√≥n de buffers del kernel</li>
                <li>Control de la tarjeta PCIe</li>
              </ul>
            </div>

            <div class="feature-box">
              <h4> Capa de Aplicaci√≥n</h4>
              <ul>
                <li>API de alto nivel (SDK)</li>
                <li>Ring buffers en user-space</li>
                <li>Thread de adquisici√≥n dedicado</li>
                <li>Procesamiento en tiempo real</li>
              </ul>
            </div>

            <div class="feature-box">
              <h4> Capa de Presentaci√≥n</h4>
              <ul>
                <li>UI no bloqueante</li>
                <li>Actualizaci√≥n por eventos</li>
                <li>Gr√°ficos acelerados</li>
                <li>Almacenamiento as√≠ncrono</li>
              </ul>
            </div>
          </div>
        </div>

        <h4>3. Comunicaci√≥n Hardware-Software</h4>

        <div class="info-box green">
          <h3>Flujo de Datos</h3>
          <pre>
1. CAPTURA (Hardware)
   Sensores ‚Üí ADC ‚Üí FIFO Buffer (8MB) ‚Üí DMA Engine

2. TRANSFERENCIA (Bus PCIe)
   DMA Engine ‚Üí PCIe Bus ‚Üí Memoria del Sistema (RAM)
   [Transferencia sin intervenci√≥n del CPU]

3. NOTIFICACI√ìN (Interrupciones)
   Tarjeta genera MSI-X ‚Üí CPU procesa ISR ‚Üí Driver notifica aplicaci√≥n

4. PROCESAMIENTO (Software)
   Ring Buffer ‚Üí Thread de procesamiento ‚Üí An√°lisis de datos
                ‚Üì
        Almacenamiento + Visualizaci√≥n
          </pre>
        </div>

        <h4>4. Influencia de los Buses del Sistema</h4>

        <table>
          <thead>
            <tr>
              <th>Aspecto</th>
              <th>Influencia del Bus</th>
              <th>Consideraci√≥n de Dise√±o</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Throughput</strong></td>
              <td>Ancho de banda PCIe determina tasa m√°xima</td>
              <td>Usar DMA para transferencias grandes, minimizar transacciones peque√±as</td>
            </tr>
            <tr>
              <td><strong>Latencia</strong></td>
              <td>Tiempo de propagaci√≥n en el bus (~100ns)</td>
              <td>Buffering adecuado para absorber variaciones</td>
            </tr>
            <tr>
              <td><strong>Coherencia</strong></td>
              <td>Sincronizaci√≥n entre CPU cache y DMA</td>
              <td>Usar memoria no cacheable o invalidar cache expl√≠citamente</td>
            </tr>
            <tr>
              <td><strong>Interrupciones</strong></td>
              <td>Overhead de context switch (~1-5¬µs)</td>
              <td>Coalescing de interrupciones, procesar m√∫ltiples muestras</td>
            </tr>
            <tr>
              <td><strong>Contenci√≥n</strong></td>
              <td>Otros dispositivos PCIe compiten por ancho de banda</td>
              <td>Priorizaci√≥n de QoS, monitoreo de performance</td>
            </tr>
          </tbody>
        </table>

        <h3> Implementaci√≥n Pr√°ctica</h3>

        <h4>Ejemplo de C√≥digo Conceptual</h4>
        <pre><code>// Estructura de configuraci√≥n DMA
struct DMAConfig {
    void* buffer_address;      // Direcci√≥n f√≠sica del buffer
    size_t buffer_size;        // Tama√±o alineado a p√°gina (4KB)
    uint32_t transfer_size;    // Bytes por transferencia DMA
    uint32_t interrupt_threshold; // Muestras antes de interrumpir
};

// Callback para datos capturados
void onDataReady(void* buffer, size_t samples) {
    // Ejecutado en contexto de ISR o thread de alta prioridad
    
    // 1. Copiar a ring buffer thread-safe
    ring_buffer_push(acquisition_buffer, buffer, samples);
    
    // 2. Se√±alizar thread de procesamiento
    sem_post(&data_ready_semaphore);
    
    // 3. Rearmar buffer para siguiente transferencia DMA
    rearm_dma_buffer(buffer);
}

// Thread de adquisici√≥n
void* acquisition_thread(void* arg) {
    // Configurar prioridad en tiempo real
    set_thread_priority(REALTIME_PRIORITY);
    
    // Configurar DMA con m√∫ltiples buffers (double/triple buffering)
    DMAConfig config = {
        .buffer_size = 4096 * 16,  // 64KB alineado
        .transfer_size = 4096,      // 4KB por transferencia
        .interrupt_threshold = 2048 // Interrupci√≥n cada 2KB
    };
    
    setup_dma_ring(&config, 4); // 4 buffers en rotaci√≥n
    
    // Iniciar captura
    start_acquisition();
    
    // Loop de procesamiento
    while (running) {
        sem_wait(&data_ready_semaphore);
        
        // Obtener datos del ring buffer
        DataPacket* packet = ring_buffer_pop(acquisition_buffer);
        
        // Procesamiento en tiempo real
        process_samples(packet->data, packet->count);
        
        // Liberar buffer
        free_packet(packet);
    }
}

// Consideraciones clave:
// 1. Buffers alineados a l√≠mites de p√°gina (4KB)
// 2. DMA ring para evitar p√©rdida de datos
// 3. Thread de alta prioridad para adquisici√≥n
// 4. Separaci√≥n entre adquisici√≥n y procesamiento
// 5. Manejo de overflow del FIFO hardware</code></pre>

        <h3>Aprendizajes Clave</h3>

        <div class="grid-2">
          <div class="info-box blue">
            <h4> Conocimientos Necesarios</h4>
            <ul>
              <li><strong>Buses PCIe:</strong> Ancho de banda, lanes, latencias</li>
              <li><strong>DMA:</strong> Transferencias directas, coherencia de cach√©</li>
              <li><strong>Interrupciones:</strong> MSI-X, manejo eficiente</li>
              <li><strong>Memoria:</strong> Alineaci√≥n, f√≠sica vs virtual</li>
              <li><strong>Drivers:</strong> Kernel-space vs user-space</li>
              <li><strong>Real-time:</strong> Scheduling, prioridades</li>
            </ul>
          </div>

          <div class="info-box purple">
            <h4> Herramientas y Tecnolog√≠as</h4>
            <ul>
              <li><strong>SDKs:</strong> COMEDI, NI-DAQmx, Windows Driver Kit</li>
              <li><strong>APIs:</strong> WinAPI, POSIX, RTAI/Xenomai (RT Linux)</li>
              <li><strong>Debugging:</strong> WinDbg, GDB, Logic analyzers</li>
              <li><strong>Profiling:</strong> Intel VTune, perf, eBPF</li>
              <li><strong>Testing:</strong> Simuladores de hardware, test benches</li>
            </ul>
          </div>
        </div>

        <div class="case-study">
          <div class="case-study-header">
            <span class="case-study-icon"></span>
            <div>
              <h4>Decisiones Cr√≠ticas del Desarrollador</h4>
            </div>
          </div>
          
          <ol>
            <li><strong>Verificaci√≥n de compatibilidad:</strong> Confirmar que el sistema tiene slots PCIe disponibles con suficiente ancho de banda</li>
            <li><strong>Dise√±o de buffers:</strong> Dimensionar correctamente para evitar overflow pero sin desperdiciar memoria</li>
            <li><strong>Gesti√≥n de threads:</strong> Separar adquisici√≥n, procesamiento y UI en threads independientes</li>
            <li><strong>Manejo de errores:</strong> Detectar y recuperarse de errores del bus o la tarjeta</li>
            <li><strong>Optimizaci√≥n:</strong> Minimizar copias de memoria, usar DMA cuando sea posible</li>
            <li><strong>Testing:</strong> Validar bajo diferentes cargas del sistema y condiciones de stress</li>
          </ol>
        </div>

        <h3>Resultados Esperados</h3>

        <div class="info-box green">
          <p>Con un dise√±o adecuado que considere las caracter√≠sticas de los buses y la tarjeta de expansi√≥n:</p>
          <ul>
            <li> Captura continua sin p√©rdida de datos a 100 kHz √ó 16 canales</li>
            <li> Latencia de extremo a extremo < 10 ms</li>
            <li> Uso de CPU < 20% en operaci√≥n normal</li>
            <li> Almacenamiento en tiempo real a disco (>50 MB/s sostenido)</li>
            <li> Visualizaci√≥n fluida sin afectar la adquisici√≥n</li>
            <li> Recuperaci√≥n autom√°tica de errores transitorios</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- P√°gina 5: Conclusiones -->
    <section id="conclusion" class="page-section">
      <div class="hero">
        <h1> Reflexiones y Conclusiones</h1>
        <p>Integrando hardware y software para mejor desarrollo</p>
      </div>

      <div class="card">
        <h2> Reflexiones Principales</h2>
        
        <div class="info-box blue">
          <h3>La Arquitectura del Hardware Importa</h3>
          <p>A trav√©s de este an√°lisis, queda claro que <span class="highlight">el conocimiento profundo de la arquitectura del hardware no es opcional para desarrolladores de software serio</span>. Los buses del sistema y las tarjetas de expansi√≥n definen los l√≠mites f√≠sicos dentro de los cuales nuestro software debe operar.</p>
        </div>

        <h3> Impacto en la Calidad del Software</h3>

        <div class="grid-2">
          <div class="feature-box">
            <h4>Rendimiento</h4>
            <p>Entender c√≥mo funcionan los buses permite:</p>
            <ul>
              <li>Dise√±ar estructuras de datos optimizadas</li>
              <li>Minimizar transferencias innecesarias</li>
              <li>Aprovechar DMA y hardware acceleration</li>
              <li>Evitar cuellos de botella predecibles</li>
            </ul>
          </div>

          <div class="feature-box">
            <h4>Confiabilidad</h4>
            <p>El conocimiento del hardware mejora:</p>
            <ul>
              <li>Detecci√≥n temprana de incompatibilidades</li>
              <li>Manejo robusto de errores</li>
              <li>Dise√±o de sistemas fault-tolerant</li>
              <li>Prevenci√≥n de condiciones de carrera</li>
            </ul>
          </div>

          <div class="feature-box">
            <h4>Eficiencia</h4>
            <p>Optimizaciones basadas en hardware:</p>
            <ul>
              <li>Reducci√≥n del consumo energ√©tico</li>
              <li>Mejor utilizaci√≥n de recursos</li>
              <li>Menor latencia en operaciones cr√≠ticas</li>
              <li>Escalabilidad mejorada</li>
            </ul>
          </div>

          <div class="feature-box">
            <h4>Mantenibilidad</h4>
            <p>C√≥digo m√°s sostenible:</p>
            <ul>
              <li>Menor deuda t√©cnica</li>
              <li>Debugging m√°s efectivo</li>
              <li>Actualizaciones m√°s sencillas</li>
              <li>Documentaci√≥n m√°s precisa</li>
            </ul>
          </div>
        </div>

        <h3> La Relaci√≥n Hardware-Software</h3>

        <div class="info-box purple">
          <h3>Dos Mundos, Una Realidad</h3>
          <p>Durante mucho tiempo, la industria trat√≥ el hardware y el software como disciplinas separadas. Sin embargo, los sistemas modernos demuestran que esta separaci√≥n es artificial y contraproducente.</p>
          
          <p><strong>El software no existe en un vac√≠o:</strong> Cada instrucci√≥n, cada transferencia de datos, cada operaci√≥n ocurre dentro de las limitaciones y posibilidades del hardware subyacente.</p>
          
          <p><strong>El hardware necesita software inteligente:</strong> El hardware m√°s avanzado es in√∫til sin software que sepa aprovecharlo. GPUs de miles de d√≥lares, tarjetas de captura especializadas, buses de alta velocidad... todos requieren desarrolladores que entiendan c√≥mo comunicarse con ellos efectivamente.</p>
        </div>

        <h3> Conclusion</h3>

        <div class="card">
          <h4>El Conocimiento es Poder Pr√°ctico</h4>
          <p>A trav√©s del caso de estudio, he comprendido que conocer los buses del sistema no es conocimiento te√≥rico abstracto. Es poder pr√°ctico que se traduce directamente en:</p>
          <ul>
            <li>Aplicaciones m√°s r√°pidas y eficientes</li>
            <li>Menos bugs relacionados con timing y sincronizaci√≥n</li>
            <li>Mejor experiencia del usuario final</li>
            <li>Sistemas m√°s robustos y confiables</li>
          </ul>
        </div>
        </div>

        <h3> Aplicaciones Pr√°cticas del Conocimiento</h3>

        <div class="grid-3">
          <div class="info-box cyan">
            <h4> Desarrollo de Juegos</h4>
            <p>Optimizar transferencias de texturas y geometr√≠a a la GPU, minimizar stalls del pipeline gr√°fico</p>
          </div>

          <div class="info-box cyan">
            <h4> Machine Learning</h4>
            <p>Maximizar utilizaci√≥n de GPUs/TPUs, optimizar transferencias de datos entre host y device</p>
          </div>

          <div class="info-box cyan">
            <h4>üè≠ IoT Industrial</h4>
            <p>Comunicaci√≥n en tiempo real con sensores, control de actuadores, procesamiento en edge</p>
          </div>

          <div class="info-box cyan">
            <h4>Sistemas de Red</h4>
            <p>Offloading de TCP/IP, RDMA, procesamiento de paquetes a alta velocidad</p>
          </div>

          <div class="info-box cyan">
            <h4> Bases de Datos</h4>
            <p>Optimizaci√≥n de I/O, uso de NVMe, cache coherence en sistemas distribuidos</p>
          </div>

          <div class="info-box cyan">
            <h4> Multimedia</h4>
            <p>Codificaci√≥n/decodificaci√≥n acelerada, captura de video, streaming de baja latencia</p>
          </div>
        </div>
      </div>
    </section>

    <!-- P√°gina 6: Referencias -->
    <section id="referencias" class="page-section">
      <div class="hero">
        <h1> Referencias</h1>
        <p></p>
      </div>

      <div class="card">
        <h2>Referencias</h2>
        
        <div class="info-box blue">
          <h3> Libros T√©cnicos</h3>
          <ol>
            <li>Hennessy, J. L., & Patterson, D. A. (2017). <em>Computer Architecture: A Quantitative Approach</em> (6th ed.). Morgan Kaufmann Publishers.</li>
            
            <li>Stallings, W. (2016). <em>Computer Organization and Architecture: Designing for Performance</em> (10th ed.). Pearson Education.</li>
            
            <li>Tanenbaum, A. S., & Austin, T. (2013). <em>Structured Computer Organization</em> (6th ed.). Pearson Education.</li>
            
            <li>Bryant, R. E., & O'Hallaron, D. R. (2015). <em>Computer Systems: A Programmer's Perspective</em> (3rd ed.). Pearson Education.</li>
          </ol>
        </div>

        <div class="info-box purple">
          <h3> </h3>
          <ol>
            <li>PCI-SIG. (2019). <em>PCI Express Base Specification Revision 5.0</em>. PCI Special Interest Group. https://pcisig.com/specifications</li>
            
            <li>USB Implementers Forum. (2019). <em>Universal Serial Bus 4 (USB4‚Ñ¢) Specification</em>. USB-IF. https://www.usb.org/document-library</li>
            
            <li>Intel Corporation. (2021). <em>Intel 64 and IA-32 Architectures Software Developer's Manual</em>. https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</li>
            
            <li>JEDEC. (2020). <em>DDR5 SDRAM Specification</em> (JESD79-5). JEDEC Solid State Technology Association.</li>
          </ol>
        </div>

        <div class="info-box cyan">
          <h3></h3>
          <ol>
            <li>Ahn, J., Yoo, S., & Lee, K. (2018). Understanding PCIe performance for end host networking. <em>ACM SIGCOMM Computer Communication Review, 48</em>(4), 1-15. https://doi.org/10.1145/3230543.3230560</li>
            
            <li>Markidis, S., Laure, E., & Kestor, G. (2018). Nvidia tensor core programmability, performance & precision. <em>2018 IEEE International Parallel and Distributed Processing Symposium Workshops</em> (pp. 522-531). IEEE.</li>
            
            <li>Berezecki, M., Frachtenberg, E., Paleczny, M., & Steele, K. (2015). Many-core key-value store. <em>2011 International Green Computing Conference and Workshops</em> (pp. 1-8). IEEE.</li>
          </ol>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div class="container">
      <!-- Footer personalizado eliminado por petici√≥n del usuario -->
    </div>
  </footer>

  <script src="script.js"></script>
</body>
</html>